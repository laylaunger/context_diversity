# Title: Degree & Divergence
# Author: Layla Unger
# Last Updated: 2025-05-23
# R version: 4.3.2
# Packages: dplyr, tidyr, purrr, stringr, scam

#####################################################
#################### DESCRIPTION ####################
#####################################################

# Use this script after the 01_degree_divergence.R script.

# This script will use files that contain word contextual 
# diversity and frequency data for a given language.

# This script is designed to compare: (A) predicting word
# AoA based just on word contextual diversity, versus (B)
# predicting word AoA based on contextual diversity while
# controlling for word frequency.

# Controlling for word frequency is vital because more
# frequent words will naturally tend to occur in a wider
# variety of contexts of other words. To partial out this
# tendency from measures of word diversity, the files
# generated by the 01_degree_divergence.R script have two 
# control measures: (1) word log frequency, and (2) the 
# same word contextual diversity measures, but calculated 
# on shuffled corpora that randomize word order.
# Shuffling corpora destroys any regularities with which
# words occur in contexts of other words (e.g., "dog" 
# should no longer reliably occur with "pet", "cat", etc),
# without altering word frequency. 

# To control for frequency, the script calculates versions 
# of diversity from which the variability accounted for by the 
# control measures has been regressed out. To account for the 
# possibility of nonlinear relationships between them,
# this is achieved by fitting GAMs that are constrained
# to have either a positive or negative relationship between
# variables (using the scam package).
# Then, the script tests the degree to which each variant
# predicts AoA (again using GAMs).

#####################################################
################### LOAD PACKAGES ###################
#####################################################

# Install any packages not yet installed

library(dplyr)
library(purrr)
library(tidyr)
library(stringr)

library(scam)

#####################################################
################### LOAD FILES ######################
#####################################################

# Load all context files into a single data frame, with a column indicating language
# List all the files and store them in a list with names that identify the 
# language they contain data for. Then read the files and combine the data in 
# a dataframe with a column indicating language.
diversity_files <- list.files(pattern = "multi_total", full.names = TRUE, recursive = TRUE)
diversity_languages <- str_replace(str_extract(diversity_files, "[[:alpha:]]+.rds"), ".rds", "")

diversity_files <- as.list(diversity_files)
names(diversity_files) <- diversity_languages

diversity <- map_dfr(diversity_files, readRDS, .id = "language")

# Load all MCDI AoA files into a single data frame, with a column indicating language
# List all the files and store them in a list with names that identify the 
# language they contain data for. Then read the files and combine the data in 
# a dataframe with a column indicating language.
mcdi_aoa_files <- list.files(pattern = "MCDI_AoA_", full.names = TRUE, recursive = TRUE)

mcdi_aoa_languages <- str_replace(str_extract(mcdi_aoa_files, "[[:alpha:]]+.csv"), ".csv", "")

mcdi_aoa_files <- as.list(mcdi_aoa_files)
names(mcdi_aoa_files) <- mcdi_aoa_languages

mcdi_aoa <- map_dfr(mcdi_aoa_files, read.csv, fileEncoding = "latin1", .id = "language")



#####################################################
################# PROCESS MCDI AOA ##################
#####################################################

# Remove words that have more than one entry in AoA norms
# (e.g., orange has an AoA for the fruit and for the color)
mcdi_aoa <- mcdi_aoa %>%
  group_by(language, word) %>%
  dplyr::mutate(entries = length(word)) %>%
  dplyr::filter(entries == 1)

# Remove words for which AoA is later than 48mo
mcdi_aoa <- mcdi_aoa[mcdi_aoa$aoa_fit <= 48,]

# Get unique mcdi_aoa words (lemmas) for each language
mcdi_aoa_words <- mcdi_aoa %>%
  ungroup() %>%
  dplyr::select(language, lemma) %>%
  dplyr::distinct()

# Filter diversity to include only words that appear in MCDI 
# AoA norms
diversity <- inner_join(diversity, mcdi_aoa_words, by = c("language" = "language", "word" = "lemma"))

# The contextual diversity measures were calculated for lemmatized
# child language input. MCDI data contain some instances where
# there are multiple word forms for a given lemma. To align
# with the contextual diversity measures, calculate the average aoa
# across different word forms corresponding to each lemma.
mcdi_aoa_lemmas <- mcdi_aoa %>%
  group_by(language, lemma) %>%
  dplyr::mutate(entries = length(lemma)) %>%
  dplyr::filter(entries == 1) %>%
  group_by(language, lemma, lexical_class) %>%
  dplyr::summarise(aoa = mean(aoa, na.rm = T),
                   aoa_fit = mean(aoa_fit, na.rm = T))

#####################################################
############## CONTROL FOR FREQUENCY ################
#####################################################

# Regress the control measures from the diversity measures.
# This function regresses a specified diversity measure 
# within a given language and window. It returns four versions
# of the measure: 
# (1) The original, uncorrected measure
# (2) The residual variance after controlling for frequency
# (3) The residual variance after controlling for the measure value
#     taken from the shuffled corpus
# (4) The residual variance after controlling for both frequency
#     and value taken from the shuffled corpus
gen_resid_window <- function(input_language_window, measure) {
  
  input_language_window <- as.data.frame(input_language_window)
  
  # Get the name of the column containing the values from the shuffled corpus
  measure_shuffled <- paste(measure, "shuffled", sep = "_")
  
  # Specify the identifying variables - language, word, and window size
  id_variable_names <- c("word", "log_freq")
  id_variables <- dplyr::select(input_language_window, id_variable_names)
  
  # Get the four variants of the measure described above
  uncorrected <- input_language_window[,measure]
  freq <- resid(scam(input_language_window[,measure] ~ s(input_language_window[,"log_freq"], k = 12, bs = "mpi") ) )
  shuffle <- resid(scam(input_language_window[,measure] ~ s(input_language_window[,measure_shuffled], k = 12, bs = "mpi") ) )
  both <- resid(scam(input_language_window[,measure] ~ s(input_language_window[,"log_freq"], k = 12, bs = "mpi") + s(input_language_window[,measure_shuffled], k = 12, bs = "mpi") ) )
  
  # Combine in a dataframe and convert to long format.
  predictors <- data.frame(id_variables, uncorrected, freq, shuffle, both)
  predictors <- pivot_longer(predictors, cols = !(id_variable_names), names_to = "correction", values_to = "value")
  
  # Add a column indicating the diversity measure
  predictors$measure <- measure
  
  return(predictors)
}

# This function simply applies the function above across all 
# languages/window sizes for a given measure
gen_resid_columns <- function(measure, lexical_classes = FALSE) {
  
  predictors <- diversity %>%
    group_by(language, window_size) %>%
    group_modify(~ {
      input <- bind_cols(.y, .x)  # add grouping vars back
      gen_resid_window(input, measure = measure)
    }) %>%
    ungroup()
  
  return(predictors)
}

# This line generates the four versions of each measure in
# each language/window size
diversity_resid <- purrr::map_dfr(
  c("degree", "divergence"),
  gen_resid_columns
)


# Convert window size to a factor
diversity_resid$window_size <- as.factor(diversity_resid$window_size)

# Look:
head(diversity_resid)

# Identify outliers 3SD+ outside the mean
diversity_resid <- diversity_resid %>%
  group_by(language, window_size, measure, correction) %>%
  dplyr::mutate(outlier = ifelse(value >  mean(value) + (3*sd(value)), 1, 0 )  )

# Combine with MCDI AoA
aoa_resid <- inner_join(mcdi_aoa_lemmas, diversity_resid, by = c("lemma" = "word", "language" = "language"))

#####################################################
## PREDICT AoA FROM FREQUENCY-CONTROLLED DIVERSITY ##
#####################################################

# This function determines whether the best-fitting
# relationship between a given diversity measure and 
# AoA is positive or negative. It fits GAMs in which
# the relationship is constrained to be positive 
# (i.e., monotonically increasing - "mpi") or negative
# (i.e., monotonically decreasing - "mpd"). The GAM
# that explains the most variance in AoA is selected
# as the winner. The function returns variance explained,
# the sign of the relationship, p-values and significance,
# and a value called var_sign, which is the variance 
# explained multiplied by -1 only if the direction is negative.
choose_spline_model <- function(input_data) {
  
  positive_model <- scam(aoa_fit ~ s(value, k = 12, bs = "mpi"), data = input_data)
  negative_model <- scam(aoa_fit ~ s(value, k = 12, bs = "mpd"), data = input_data)
  positive_expl <- summary(positive_model)$dev.expl
  negative_expl <- summary(negative_model)$dev.expl
  
  if(positive_expl > negative_expl) {
    choice_model <- positive_model
    sign <- "positive"
  } else {
    choice_model <- negative_model
    sign <- "negative"
  }
  
  var_explained <- summary(choice_model)["dev.expl"]$dev.expl[1]
  p_value <- summary(choice_model)["s.pv"]$s.pv[1]
  
  output <- data.frame(var_explained,
                       p_value,
                       sign)
  
  # Convert variance explained and p-value to numeric and round to 3 significant digits
  output <- output %>% mutate_at(c("var_explained", "p_value"), as.numeric)
  output <-  output %>% mutate_at(c("var_explained", "p_value"), round, digits = 3)
  
  # Specify whether diversity measure was sig or ns
  output$sig <- ifelse(output$p_value < .05, "sig", "ns")
  
  # Generate var_sign value, which is just var_explained multiplied by -1 if the direction is negative
  output$var_sign <- ifelse(output$sign == "positive", output$var_explained, output$var_explained * -1)
  return(output)
}


# Apply the function above to each measure variant, window size and language

# Choose to either remove or keep words identified as outliers above
# (comment/uncomment accordingly)
diversity_control <- aoa_resid %>%
  #dplyr::filter(outlier == 0) %>%
  group_by(measure, correction, language, window_size) %>%
  group_modify(~  choose_spline_model(.x)) 

# diversity_control <- ddply(aoa_resid, .(measure, correction, language, window_size), choose_spline_model)
# diversity_control <- ddply(aoa_resid[aoa_resid$outlier == 0,], .(measure, correction, language, window_size), choose_spline_model)

# Look:
head(diversity_control)

# Save diversity
aoa_resid_file <- here::here("data", "context_diversity", "aoa_resid.rds")
diversity_file <- here::here("data", "context_diversity", "diversity.rds")
diversity_control_file <- here::here("data", "context_diversity", "diversity_control.rds")

saveRDS(aoa_resid, aoa_resid_file)
saveRDS(diversity, diversity_file)
saveRDS(diversity_control, diversity_control_file)



