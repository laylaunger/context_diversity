#####################################################
#################### DESCRIPTION ####################
#####################################################

# Use this script after either downloading the contextual 
# diversity measures, or generating them using the 
# Context Diversity - Multi Measure.R script.

# This script will use files that contain word contextual 
# diversity and frequency data for a given language.

# This script is designed to compare: (A) predicting word
# AoA based just on word contextual diversity, versus (B)
# predicting word AoA based on contextual diversity while
# controlling for word frequency.

# Controlling for word frequency is vital because more
# frequent words will naturally tend to occur in a wider
# variety of contexts of other words. To partial out this
# tendency from measures of word diversity, the files
# generated by the Context Diversity - Multi Measure.R
# script have two control measures: (1) word log frequency,
# and (2) the same word contextual diversity measures, but
# calculated on shuffled corpora that randomize word order.
# Shuffling corpora destroys any regularities with which
# words occur in contexts of other words (e.g., "dog" 
# should no longer reliably occur with "pet", "cat", etc),
# without altering word frequency. 

# To control for frequency, the script calculates versions 
# of diversity from which the variability accounted for by the 
# control measures has been regressed out. 
# Then, the script tests the degree to which each variant
# predicts AoA.

#####################################################
################### LOAD PACKAGES ###################
#####################################################

# Install any packages not yet installed

library(plyr)
library(dplyr)
library(purrr)
library(tidyr)
library(stringr)

library(scam)

#####################################################
################### LOAD FILES ######################
#####################################################

# Load all context files into a single data frame, with a column indicating language
diversity_files <- list.files(pattern = "multi_total", full.names = TRUE, recursive = TRUE)
diversity_languages <- str_replace(str_extract(diversity_files, "[[:alpha:]]+.rds"), ".rds", "")

diversity_files <- as.list(diversity_files)
names(diversity_files) <- diversity_languages

diversity <- map_dfr(diversity_files, readRDS, .id = "language")

# Load all mcdi_aoa files into a single data frame, with a column indicating language
mcdi_aoa_files <- list.files(pattern = "MCDI_AoA_", full.names = TRUE, recursive = TRUE)

mcdi_aoa_languages <- str_replace(str_extract(mcdi_aoa_files, "[[:alpha:]]+.csv"), ".csv", "")

mcdi_aoa_files <- as.list(mcdi_aoa_files)
names(mcdi_aoa_files) <- mcdi_aoa_languages

mcdi_aoa <- map_dfr(mcdi_aoa_files, read.csv, fileEncoding = "latin1", .id = "language")

mcdi_aoa %>%
  group_by(language) %>%
  dplyr::summarise(num_words = length(word))

#####################################################
################# PROCESS MCDI AOA ##################
#####################################################

# Remove words that have more than one entry in AoA norms
# (e.g., orange has an AoA for the fruit and for the color)
mcdi_aoa <- mcdi_aoa %>%
  group_by(language, word) %>%
  dplyr::mutate(entries = length(word)) %>%
  dplyr::filter(entries == 1)

# Remove words for which AoA is later than 48mo
mcdi_aoa <- mcdi_aoa[mcdi_aoa$aoa_fit <= 48,]

# Filter diversity to include only words that appear in MCDI 
# AoA norms
mcdi_aoa_words <- mcdi_aoa[,c("language", "lemma")] %>%
  dplyr::distinct()

diversity <- inner_join(diversity, mcdi_aoa_words, by = c("language" = "language", "word" = "lemma"))

num_mcdi_words <- mcdi_aoa %>%
  group_by(language) %>%
  dplyr::summarise(mcdi_num = length(word))

num_diversity_words <- diversity %>%
  group_by(language) %>%
  dplyr::summarise(diversity_num = length(unique(word)))

num_words <- full_join(num_mcdi_words, num_diversity_words)

num_words <- num_words %>%
  dplyr::mutate(prop_exclude = 1 - diversity_num / mcdi_num)

#####################################################
############## CONTROL FOR FREQUENCY ################
#####################################################

# Regress the control measures from the diversity measures.
# This function regresses a specified diversity measure 
# within a given language and window. It returns four versions
# of the measure: 
# (1) The original, uncorrected measure
# (2) The residual variance after controlling for frequency
# (3) The residual variance after controlling for the measure value
#     taken from the shuffled corpus
# (4) The residual variance after controlling for both frequency
#     and value taken from the shuffled corpus
gen_resid_window <- function(input_language_window, measure) {
  
  # Get the name of the column containing the values from the shuffled corpus
  measure_shuffled <- paste(measure, "shuffled", sep = "_")
  
  # Specify the identifying variables - language, word, and window size
  id_variable_names <- c("language", "word", "window_size", "log_freq")
  id_variables <- dplyr::select(input_language_window, id_variable_names)
  
  # Get the four variants of the measure described above
  uncorrected <- input_language_window[,measure]
  freq <- resid(scam(input_language_window[,measure] ~ s(input_language_window[,"log_freq"], k = 12, bs = "mpi") ) )
  shuffle <- resid(scam(input_language_window[,measure] ~ s(input_language_window[,measure_shuffled], k = 12, bs = "mpi") ) )
  both <- resid(scam(input_language_window[,measure] ~ s(input_language_window[,"log_freq"], k = 12, bs = "mpi") + s(input_language_window[,measure_shuffled], k = 12, bs = "mpi") ) )
  
  # Combine in a dataframe and convert to long format.
  predictors <- data.frame(id_variables, uncorrected, freq, shuffle, both)
  predictors <- pivot_longer(predictors, cols = !(id_variable_names), names_to = "correction", values_to = "value")
  
  # Add a column indicating the diversity measure
  predictors$measure <- measure
  
  return(predictors)
}

# This function simply applies the function above across all 
# languages/window sizes for a given measure
gen_resid_columns <- function(measure, lexical_classes = FALSE) {
  
  predictors <- ddply(diversity, .(language, window_size), gen_resid_window, measure = measure)
  
  return(predictors)
}

# This line generates the four versions of each measure in
# each language/window size
diversity_resid <- ldply(c("degree", "divergence"), gen_resid_columns)

# Convert window size to a factor
diversity_resid$window_size <- as.factor(diversity_resid$window_size)

# Look:
head(diversity_resid)

# Identify outliers 3SD+ outside the mean
diversity_resid <- diversity_resid %>%
  group_by(language, window_size, measure, correction) %>%
  dplyr::mutate(outlier = ifelse(value >  mean(value) + (3*sd(value)), 1, 0 )  )

# Combine with MCDI AoA
aoa_resid <- inner_join(mcdi_aoa, diversity_resid, by = c("lemma" = "word", "language" = "language"))

#####################################################
## PREDICT AoA FROM FREQUENCY-CONTROLLED DIVERSITY ##
#####################################################

# This function determines whether the best-fitting
# relationship between a given diversity measure and 
# AoA is positive or negative. It fits GAMs in which
# the relationship is constrained to be positive 
# (i.e., monotonically increasing - "mpi") or negative
# (i.e., monotonically decreasing - "mpd"). The GAM
# that explains the most variance in AoA is selected
# as the winner. The function returns variance explained,
# the sign of the relationship, p-values and significance,
# and a value called var_sign, which is the variance 
# explained multiplied by -1 only if the direction is negative.
choose_spline_model <- function(input_data) {
  
  positive_model <- scam(aoa_fit ~ s(value, k = 12, bs = "mpi"), data = input_data)
  negative_model <- scam(aoa_fit ~ s(value, k = 12, bs = "mpd"), data = input_data)
  positive_expl <- summary(positive_model)$dev.expl
  negative_expl <- summary(negative_model)$dev.expl
  
  if(positive_expl > negative_expl) {
    choice_model <- positive_model
    sign <- "positive"
  } else {
    choice_model <- negative_model
    sign <- "negative"
  }
  
  var_explained <- summary(choice_model)["dev.expl"]$dev.expl[1]
  p_value <- summary(choice_model)["s.pv"]$s.pv[1]
  
  output <- data.frame(var_explained,
                       p_value,
                       sign)
  
  # Convert variance explained and p-value to numeric and round to 3 significant digits
  output <- output %>% mutate_at(c("var_explained", "p_value"), as.numeric)
  output <-  output %>% mutate_at(c("var_explained", "p_value"), round, digits = 3)
  
  # Specify whether diversity measure was sig or ns
  output$sig <- ifelse(output$p_value < .05, "sig", "ns")
  
  # Generate var_sign value, which is just var_explained multiplied by -1 if the direction is negative
  output$var_sign <- ifelse(output$sign == "positive", output$var_explained, output$var_explained * -1)
  return(output)
}


# Apply the function above to each measure variant, window size and language

# Choose to either remove or keep words identified as outliers above
# (comment/uncomment accordingly)

diversity_control <- ddply(aoa_resid, .(measure, correction, language, window_size), choose_spline_model)
diversity_control <- ddply(aoa_resid[aoa_resid$outlier == 0,], .(measure, correction, language, window_size), choose_spline_model)

# Look:
head(diversity_control)

# Format variables for plotting.
diversity_control$sign <- factor(diversity_control$sign, levels = c("positive", "negative"))

diversity_control$correction <- factor(diversity_control$correction, levels = c("uncorrected", "freq", "shuffle", "both"))

diversity_control$language <- factor(diversity_control$language, levels = c("english", "spanish", "french", "german"))

diversity_control$measure <- factor(diversity_control$measure, levels = c("degree", "divergence"))
levels(diversity_control$measure) <- c("Degree", "Divergence")

######################################################
########### SUPPLEMENT: LINEAR REGRESSION ############
######################################################

# This section applies the same steps as above, but using linear
# regression rather than GAMs

# Regress control measures of frequency
gen_resid_window_lin <- function(input_language_window, measure) {
  
  # Get the name of the column containing the values from the shuffled corpus
  measure_shuffled <- paste(measure, "shuffled", sep = "_")
  
  # Specify the identifying variables - language, word, and window size
  id_variable_names <- c("language", "word", "window_size", "log_freq")
  id_variables <- dplyr::select(input_language_window, id_variable_names)
  
  # Get the four versions of the measure described above
  uncorrected <- input_language_window[,measure]
  freq <- resid(lm(input_language_window[,measure] ~ input_language_window[,"log_freq"]))
  shuffle <- resid(lm(input_language_window[,measure] ~ input_language_window[,measure_shuffled]))
  both <- resid(lm(input_language_window[,measure] ~ input_language_window[,"log_freq"] + input_language_window[,measure_shuffled]))
  
  # Combine in a dataframe and convert to long format.
  predictors <- data.frame(id_variables, uncorrected, freq, shuffle, both)
  predictors <- pivot_longer(predictors, cols = !(id_variable_names), names_to = "correction", values_to = "value")
  
  # Add a column indicating the diversity measure
  predictors$measure <- measure
  
  return(predictors)
}

# This function simply applies the function above across all 
# languages/window sizes for a give measure
gen_resid_columns_lin <- function(measure) {
  
  predictors <- ddply(diversity, .(language, window_size), gen_resid_window_lin, measure = measure)
  
  return(predictors)
}

# This line generates the four versions of each measure in
# each language/window size
diversity_resid_lin <- ldply(c("degree", "divergence"), gen_resid_columns_lin)

# Convert window size to a factor
diversity_resid_lin$window_size <- as.factor(diversity_resid_lin$window_size)

# Look:
head(diversity_resid_lin)

# Identify outliers 3SD+ outside the mean
diversity_resid_lin <- diversity_resid_lin %>%
  group_by(language, window_size, measure, correction) %>%
  dplyr::mutate(outlier = ifelse(value >  mean(value) + (3*sd(value)), 1, 0 )  )

# Combine with MCDI AoA
aoa_resid_lin <- inner_join(mcdi_aoa, diversity_resid_lin, by = c("lemma" = "word", "language" = "language"))

# Compare corrected and uncorrected variants as predictors
# of AoA
control_freq_lin <- function(input_data) {
  
  input_data <- input_data[input_data$outlier == 0,]
  
  # Use linear regression to predict AoA from uncorrected and corrected variants of diversity
  diversity_only <- summary(lm(aoa_fit ~ value, data = input_data[input_data$correction == "uncorrected",]))
  diversity_freq <- summary(lm(aoa_fit ~ value, data = input_data[input_data$correction == "freq",]))
  diversity_shuffle <- summary(lm(aoa_fit ~ value, data = input_data[input_data$correction == "shuffle",]))
  diversity_both <- summary(lm(aoa_fit ~ value, data = input_data[input_data$correction == "both",]))
  
  # Combine variance explained, estimate of effect, and p-value from each regression
  diversity_only <- c(diversity_only$r.squared, diversity_only$coefficients["value","Estimate"], diversity_only$coefficients["value","Pr(>|t|)"])
  diversity_freq <- c(diversity_freq$r.squared, diversity_freq$coefficients["value","Estimate"], diversity_freq$coefficients["value","Pr(>|t|)"])
  diversity_shuffle <- c(diversity_shuffle$r.squared, diversity_shuffle$coefficients["value","Estimate"], diversity_shuffle$coefficients["value","Pr(>|t|)"])
  diversity_both <- c(diversity_both$r.squared, diversity_both$coefficients["value","Estimate"], diversity_both$coefficients["value","Pr(>|t|)"])
  
  output <- data.frame(rbind(diversity_only, diversity_freq, diversity_shuffle, diversity_both))
  
  names(output) <- c("var_explained", "estimate", "p_value")
  
  # Convert variance explained and p-value to numeric and round to 3 significant digits
  output <- output %>% mutate_at(c("var_explained", "p_value"), as.numeric)
  output <-  output %>% mutate_at(c("var_explained", "p_value"), round, digits = 3)
  
  output$correction <- c("uncorrected", "freq", "shuffle", "both")
  output$sig <- ifelse(output$p_value < .05, "sig", "ns")
  output$sign <- ifelse(output$estimate < 0, "negative", "positive")
  output$var_sign <- ifelse(output$sign == "negative", output$var_explained * -1, output$var_explained)
  
  return(output)
  
}

# Apply the function to each measure, language and window
diversity_control_lin <- ddply(aoa_resid_lin, .(measure,  language, window_size), control_freq_lin)


# Format variables.
diversity_control_lin$language <- factor(diversity_control_lin$language, levels = c("english", "spanish", "french", "german"))
diversity_control_lin$sign <- factor(diversity_control_lin$sign, levels = c("positive", "negative"))
diversity_control_lin$correction <- factor(diversity_control_lin$correction, levels = c("uncorrected", "freq", "shuffle", "both"))

diversity_control_lin$measure <- factor(diversity_control_lin$measure, levels = c("degree", "divergence"))
levels(diversity_control_lin$measure) <- c("Degree", "Divergence")

